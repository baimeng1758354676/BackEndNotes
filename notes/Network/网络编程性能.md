# 网络编程实战-性能篇

## select：I/O 多路复用

### 什么是 I/O 多路复用

可以把标准输入输出、套接字等都看做是 I/O 的一路，多路复用的意思就是在任何一路 I/O 有“事件”发生的情况下，通知应用程序去处理相应的 I/O 事件，这样我们的程序就变成了“多面手”，在同一时刻仿佛可以处理多个 I/O 事件。

使用 I/O 复用以后，如果标准输入有数据，立即从标准输入读入数据，通过套接字发送出去；如果套接字有数据可以读，立即可以读出数据。

其中，select 函数就是一种常见的 I/O 多路复用技术。使用 select 函数，通知内核挂起进程，当一个或多个 I/O 事件发生后，控制权返还给应用程序，由应用程序进行 I/O 事件的处理。

常见的 I/O 事件的类型：

* 标准输入文件描述符准备好可以读。
* 监听套接字准备好，新的连接已经建立成功。
* 已连接套接字准备好可以写。
* 如果一个 I/O 事件等待超过了 10 秒，发生了超时事件。

### select 函数的使用方法

select 函数的原型：

```c
int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```

* maxfd：表示的是待测试的描述符基数，它的值是待测试的最大描述符加 1
* readset：读描述符集合 、writeset：写描述符集合、exceptset：异常描述符集合，这三个描述符集合分别通知内核，在哪些描述符上检测数据可以读，可以写和有异常发生
* timeval：是一个结构体时间
* 返回值：若有就绪描述符则为其数目，若超时则为 0，若出错则为 -1

**理解 maxfd：**

比如现在的 select 待测试的描述符集合是 `{0,1,4}`，那么 maxfd 就是 5。

**理解 三个描述符集合：**

可以通过下面的宏设置这些描述符集合：

可以这样类比，用一个向量代表了一个描述符集合，其中，这个向量的每个元素都是二进制数中的 0 或者 1。其中 0 代表不需要处理，1 代表需要处理。

```c
a[maxfd-1], ..., a[1], a[0]

// 把这个向量的所有元素都设置成 0；
void FD_ZERO(fd_set *fdset);

// 把对应套接字 fd 的元素，a[fd]设置成 1；
void FD_SET(int fd, fd_set *fdset);

// 把对应套接字 fd 的元素，a[fd]设置成 0；
void FD_CLR(int fd, fd_set *fdset);

// 对这个向量进行检测，判断出对应套接字的元素 a[fd]是 0 还是 1；
int FD_ISSET(int fd, fd_set *fdset);
```

实际上，很多系统是用一个整型数组来表示一个描述字集合的，一个 32 位的整型数可以表示 32 个描述字。

**理解 timeval：**

```c
// 具体实现
struct timeval {
  long tv_sec; /* seconds */
  long tv_usec; /* microseconds */
};
```

不同的 timeval 会有不同的可能：

* 设置为 **NULL**，表示如果没有 I/O 事件发生，则 select 一直等待下去
* 设置为 **一个非零值**，表示等待固定的一段时间后从 select 阻塞调用中返回
* 设置为 **tv_sec 和 tv_usec 都等于 0**，表示根本不等待，检测完毕立即返回，这种情况使用得比较少。

**一个例子：**

```c

int main(int argc, char **argv) {
    if (argc != 2) {
        error(1, 0, "usage: select01 <IPaddress>");
    }
    int socket_fd = tcp_client(argv[1], SERV_PORT);

    char recv_line[MAXLINE], send_line[MAXLINE];
    int n;

    fd_set readmask;
    fd_set allreads;
    FD_ZERO(&allreads);     // 步骤1：初始化一个描述符集合，这个描述符读集合是空的
    // 步骤2：分别使用 FD_SET 将描述符 0，即标准输入，
    // 以及连接套接字描述符 3 设置为待检测
    FD_SET(0, &allreads);
    FD_SET(socket_fd, &allreads);

    // 循环测试
    for (;;) {
        // 每次测试完之后，重新设置待测试的描述符集合
        readmask = allreads;

        // 通过 select 来检测套接字描述字有数据可读，或者标准输入有数据可读
        int rc = select(socket_fd + 1, &readmask, NULL, NULL, NULL);

        if (rc <= 0) {
            error(1, errno, "select failed");
        }

        // 判断是套接字可读，使用 read 将套接字数据读出
        if (FD_ISSET(socket_fd, &readmask)) {
            // 将套接字数据读出
            n = read(socket_fd, recv_line, MAXLINE);
            if (n < 0) {
                error(1, errno, "read error");
            } else if (n == 0) {
                error(1, 0, "server terminated \n");
            }
            recv_line[n] = 0;
            fputs(recv_line, stdout);
            fputs("\n", stdout);
        }

        // 判断是标准输入可读，读入后发送给对端
        if (FD_ISSET(STDIN_FILENO, &readmask)) {
            // 读入数据
            if (fgets(send_line, MAXLINE, stdin) != NULL) {
                int i = strlen(send_line);
                if (send_line[i - 1] == '\n') {
                    send_line[i - 1] = 0;
                }

                printf("now sending %s\n", send_line);
                // 发送给对端
                sszie_t rt = write(socket_fd, send_line, strlen(send_line));
                if (rt < 0) {
                    error(1, errno, "write failed ");
                }
                printf("send bytes: %zu \n", rt);
            }
        }
    }

}
```

**步骤1**，描述符集合情况：

* 0 代表 描述符读集合
* 1 代表 描述符写集合
* 2 代表 描述符异常集合
* 3 代表 描述符套接字集合

![描述符集合1](resources/描述符集合1.png)

**步骤2**，描述符集合情况：

![描述符集合2](resources/描述符集合2.png)

### 套接字描述符就绪条件

select 测试返回，某个套接字准备好**可读**，表示什么样的事件发生呢？

* 情况1：套接字接收缓冲区有数据可以读，如果我们使用 read 函数去执行读操作，肯定不会被阻塞，而是会直接读到这部分数据。
* 情况2：对方发送了 FIN，使用 read 函数执行读操作，不会被阻塞，直接返回 0。
* 情况3：针对一个监听套接字而言的，有已经完成的连接建立，此时使用 accept 函数去执行不会阻塞，直接返回已经完成的连接。
* 情况4：套接字有错误待处理，使用 read 函数去执行读操作，不阻塞，且返回 -1。

总结就是**内核通知我们套接字有数据可以读了，使用 read 函数不会阻塞。**

select 测试返回，某个套接字准备好**可写**，表示什么样的事件发生呢？

* 情况1：套接字发送缓冲区足够大（实际上，只要有一个字节可以被写入，就是状态可写的），如果我们使用套接字进行 write 操作，将不会被阻塞，直接返回。
* 情况2：连接的写半边已经关闭，如果继续进行写操作将会产生 SIGPIPE 信号。
* 情况3：套接字上有错误待处理，使用 write 函数去执行写操作，不阻塞，且返回 -1。

总结就是**内核通知我们套接字可以往里写了，使用 write 函数就不会阻塞。**

**总结：**

### 思考

**问题1：**

select 可以对诸如 UNIX 管道（pipe）这样的描述字进行检测吗？如果可以，检测的就绪条件是什么呢？

**解答：**

管道也是文件，所以可以进行检测。往管道输入数据和输出数据对应可读可写的就绪条件。

**问题2：**

根据前面的知识，一个描述符集合哪些描述符被设置为 1，需要进行检测是完全可以知道的，select 函数里一定需要传入描述字基数这个值吗？这样设计的目的是什么？

**解答：**

可以把 fd_set 理解成数组，如果不传入描述字基数，无法得知 fd_set 的具体大小，就无法进行遍历操作。

**问题3：**

我们知道 select 函数的原型如下，为什么 maxfd 有 1024的限制呢？

```c
int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);
```

**解答：**

因为 fd_set 是固定大小的缓冲区。fd 值为负或等于或大于 FD_SETSIZE 执行 FD_CLR（）或 FD_SET（）会导致不确定的行为。 而且，POSIX 要求 fd 是有效的文件描述符。其中，在进行位图运算的时候会受到 FD_SETSIZE 的影响。

```c
// sys/select.h头文件有如下定义：

#define FD_SETSIZE __FD_SETSIZE

// typesizes.h头文件有如下定义：
#define __FD_SETSIZE 1024
```

## poll：另一种 I/O 多路复用

select 方法是多个 UNIX 平台支持的非常常见的 I/O 多路复用技术，它通过**描述符集合**来表示检测的 I/O 对象，通过三个不同的描述符集合来描述 I/O 事件 ：可读、可写和异常。但是 select 有一个**缺点**，那就是所支持的文件描述符的个数是有限的，在 Linux 系统中，select 的默认最大值为 1024。

poll 可以突破文件描述符个数限制，并且它和内核交互的数据结构也有所变化。

### poll 函数的使用方法

poll 函数的原型：

```c

```
